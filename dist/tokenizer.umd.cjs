(function(r,i){typeof exports=="object"&&typeof module<"u"?i(exports):typeof define=="function"&&define.amd?define(["exports"],i):(r=typeof globalThis<"u"?globalThis:r||self,i(r.tokenizer={}))})(this,function(r){"use strict";var A=Object.defineProperty;var I=(r,i,u)=>i in r?A(r,i,{enumerable:!0,configurable:!0,writable:!0,value:u}):r[i]=u;var c=(r,i,u)=>I(r,typeof i!="symbol"?i+"":i,u);const i=Symbol("space"),u=Symbol("exclamation"),N=Symbol("newline"),d=Symbol("blank");class g{constructor(t,s="",e=1,h=1,o=1){c(this,"name");c(this,"value");c(this,"line");c(this,"start");c(this,"end");this.name=t,this.value=s,this.line=e,this.start=h,this.end=o}get length(){return this.value.length}}function m(n){return n.split(`
`).length}class v extends Array{get first(){return this[0]}get latest(){return this[this.length-1]}pushToLatestNode(t,s){let e=this[this.length-1];if(!e)this.push(e=new g(s,t,1,1,(t||"").length));else if(e.name!==s)this.push(e=new g(s,t,e.line,e.start+1,(t||"").length));else if(e.name===s){const h=m(t)-1;e.value+=t,e.end+=t.length,h>0&&(e.line+=h)}return e}push(t){const s=this[this.length-1];return s&&(t.start=s.end+1,t.end=t.start+t.value.length-1,t.line=s.line+m(t.value)-1),super.push(t)}toString(){return this.map(t=>t.value).join("")}}var y=Object.defineProperty,T=(n,t,s)=>t in n?y(n,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[t]=s,a=(n,t,s)=>T(n,typeof t!="symbol"?t+"":t,s);class E{constructor(t){a(this,"BEGINNING",Symbol("beginning")),a(this,"ENDING",Symbol("ending")),a(this,"raw",""),a(this,"cursor",0),this.raw=t}get current(){return this.raw[this.cursor]}get next(){return this.raw[++this.cursor]}get prev(){return this.raw[--this.cursor]}matches(t){return this.raw.slice(this.cursor,this.cursor+t.length)===t}before(t){return this.raw.slice(this.cursor-t.length,this.cursor)===t}after(t){return this.raw.slice(this.cursor+1,this.cursor+t.length+1)===t}distanceTo(t){const s=t===this.BEGINNING?this.cursor:t===this.ENDING?this.raw.length-this.cursor-1:this.raw.indexOf(t,this.cursor)-this.cursor-1;return s<0?1/0:s}closest(t){return t.map(s=>[s,this.distanceTo(s)]).sort((s,e)=>s[1]-e[1])}startTransaction(){const{cursor:t}=this;function s(){this.cursor=t}return s.bind(this)}getUntil(t){const s=this.raw.indexOf(t,this.cursor);if(s===-1)return;const e=this.raw.slice(this.cursor,s);return this.cursor+=e.length,e}slice(t){if(t<0)throw new RangeError(`Cannot slice backwards from ${this.cursor} to ${t}.`);const s=this.raw.slice(this.cursor,this.cursor+t);return this.cursor=t===1/0?this.raw.length:this.cursor+t,s}move(t){return this.cursor+=t,this}moveTo(t){return this.cursor=t,this}jumpTo(t){return this.cursor=this.raw.indexOf(t,this.cursor)}consume(t){let s;const e=this.cursor;for(Array.isArray(t)||(t=[t]);(s=t.findIndex(h=>this.matches(h)))>-1;)this.move(t[s].length);return this.raw.slice(e,this.cursor)}}function S(n,t,{mergeTokens:s=!1}={}){const e=new v,h=new E(n);do{let o;t:for(let[w,f,{merge:p}={}]of t){let b=s;typeof f=="string"&&(f=[f]),p!==void 0&&(b=p);for(const l of f)if(h.matches(l)){b?o=e.pushToLatestNode(l,w):(o=new g(w,l),o.end=h.cursor+l.length,e.push(o)),h.cursor+=l.length-1;break t}}o||e.pushToLatestNode(h.current,d)}while(h.next!==void 0);return e}r.BLANK=d,r.EXCLAMATION=u,r.NEWLINE=N,r.SPACE=i,r.tokenize=S,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
